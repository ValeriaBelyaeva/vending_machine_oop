# Вендинговый автомат (консольное приложение)

Небольшой учебный проект на C#, демонстрирующий **знание ООП** и **самодокументирующиеся модульные тесты**. Приложение — консольный интерфейс симулирующий вендинговый автомат: деньги/сдача, касса с хранилищем монет, инвентарь товаров, покупка и админ-режим.


## Ключевые идеи

* **Без Console-зависимостей.** Консоль — тонкая оболочка (`App`), всё поведение живёт в моделях.
* **ООП с сильной типизацией и неизменяемыми значениями**: `CurrencyAmount`, `Coin`, аккуратная арифметика денег без `double`.
* **Паттерны проектирования**: *Strategy* для алгоритма сдачи (`IChangeStrategy` → `GreedyChangeStrategy`), *Value Object*, *Aggregate-подобные* сущности (`CashRegister`, `VendingMachine`), *Result*-тип для управляемых отказов.
* **Инкапсуляция, инварианты и снапшоты.** Касса не «протекает» наружу; выдаются копии коллекций.
* **Тесты — как исполняемая спецификация**: покрывают как happy-path так и граничные случаи, читаются как требования.

# Короткий обзор
## Контракты и инварианты

* Нормальные отказы — `Result.Failure`; исключения — только при нарушении инвариантов.
* `Inventory`: уникальный `Id`, количество ≥ 0.
* `CashRegister`: наружу только копии словарей; расчёт сдачи на снимке `(vault+hopper)`.

## Тесты и расширяемость

* xUnit покрывает деньги, сдачу, кассу, покупки, админ; есть happy/negative-path.
* Расширение: подмена стратегии сдачи (любой `IChangeStrategy`), добавление UI (Web/API/GUI) без изменений домена.


---

## ООП

### 1) Value Object для денег: `CurrencyAmount`

* **`readonly struct`** + **иммутабельность**: внутреннее состояние (`Kopeks`) задаётся лишь в фабриках `FromRubles`/`FromKopeks`.
* **Единица хранения — копейки (`int`)**: исключаем ошибки округления и накопления погрешности.
* **Корректное округление при вводе**: `MidpointRounding.AwayFromZero` (`1.005 → 1.01р → 101 коп`).
* **Полный набор семантики значения**: `IComparable`, `IEquatable`, перегруженные операторы `+`, `-`, `>, <, <=, >=`, нормальный `GetHashCode`.
* **Локализованный вывод**: `ru-RU`, формат `0.00 ₽`.

> Принципы: *SRP* (одна ответственность — арифметика/формат денег), *Encapsulation*, *Tell, don’t ask* (вызываем методы/операторы, а не лезем во внутренности).

### 2) Деноминации и монеты

* `Denomination` — **enum** со значением, равным номиналу в копейках; `Coin` — **`record`** с вычисляемым `Kopeks`.
* Чёткое разделение: *деноминация* как тип, *монета* как объект.

### 3) Паттерн **Strategy** для выдачи сдачи

* Контракт: `IChangeStrategy.TryMakeChange(amount, available, out change)`.
* Реализация: `GreedyChangeStrategy` — идём по номиналам по убыванию, учитывая **ограниченное** количество монет.
* **Заменяемость**: можно подставить, например, `DynamicProgrammingChangeStrategy`, не трогая кассу.

> Принципы: *O* из **SOLID** (открытость для расширения), *D* — `CashRegister` зависит от абстракции `IChangeStrategy`, не от конкретики.

### 4) Касса `CashRegister`: инварианты и слои

* Два «кармана»:

  * **`vault`** — всё «официально» принадлежащее автомату;
  * **`hopper`** — временно внесённые монеты пользователя.
* **Инварианты**:

  * Баланс — производная от карт номиналов, наружу не выдаётся в изменяемом виде.
  * Все изменения — через методы (`Insert`, `RefundInserted`, `CommitPurchaseAndMakeChange`, `AddFloat`, `EmptyVault`).
  * Выдача сдачи идёт **только** после рассчёта на **снимке** `(vault + hopper)`, затем перенос `hopper → vault`, затем списание сдачи.
  * Списания аккуратны: частичное списание с остатком (`DeductFrom`), удаление нулевых позиций.
* **Безопасность данных**: наружу — только **копии** словарей (снапшоты), внутренние коллекции приватны.

> Принципы: *Encapsulation*, *SRP*, *Fail-fast*: несогласованность — `InvalidOperationException` (ошибка программной логики).

### 5) Инвентарь `Inventory<T> where T : IProduct`

* **Дженерик** поверх минимального контракта `IProduct`.
* Содержит строки (`Line`) с парой *товар+количество*.
* Гарантии:

  * **Уникальность** `Id` при добавлении (`AddNew`).
  * Нельзя уйти в минус (`TryDecrease` возвращает `false`).
  * Управляемое пополнение (`TryAddStock`).
* Доменные типы `Product` (абстрактный), `Drink`/`Snack` (sealed) показывают **строгое наследование** без лишней вариативности.

> Принципы: *LSP* (подтипы не ломают контракт), *ISP* (тонкий `IProduct`), *SRP* (управление остатками отдельно от денег).

### 6) Фасады: `VendingMachine` и `AdminSession`

* `VendingMachine` — **единая точка входа** для операций покупателя: приём монет, покупка, отмена.

  * В `Buy` явная валидация: наличие товара, остаток, средств, **возможность сдачи**.
  * Возвращает **`Result<Receipt>`**, а не бросает исключения при ожидаемых ошибках (недостаточно средств, нет сдачи).
* `AdminSession` — выдаётся только по корректному PIN через `TryEnterAdmin`; **внутренний** конструктор исключает создание в обход автомата.

  * Операции: пополнение кассы/товаров, снятие денег, просмотр снапшотов.

> Принципы: *Information Hiding*, *Security by design* (минимизация поверхности), *CQRS-намеки*: чтения (снапшоты) отделены от команд.

### 7) Ошибки и результат: `Result<T>` и `Receipt`

* **Функциональный стиль** для ожидаемых отказов: `Success(value)`/`Failure(error)`.
* **Исключения** — только для нарушений инвариантов/логических ошибок (например, рассинхрон кассы после предварительной проверки).

## Алгоритм сдачи и корректность

* Жадный алгоритм корректно работает для «канонических» наборов номиналов (1–2–5–10), и учитывает **лимиты по количеству** монет.
* Сначала считаем на **снимке** (vault + hopper) — это даёт атомарность решения. Затем переносим `hopper → vault`, списываем сдачу из `vault`, *на всякий случай* пытаемся добрать из `hopper` (который, по идее, пуст уже).
* При неудаче после предварительной проверки — **fail-fast** с исключением.
---

## Тестирование: самодокументирующиеся спецификации

Тесты на **xUnit** разбиты по доменным областям. Имена методов отражают поведение — их можно читать как требования. Покрываются и счастливые пути, и отрицательные сценарии, и граничные случаи.

### Разделы и примеры

* **Деньги** (`MoneyAndCurrencyAmountTests`)

  * Форматирование строки с запятой и ₽.
  * Правила округления «от нуля» на границах (теория с `InlineData`).
  * Корректность операторов и сравнений.

* **Сдача** (`ChangeStrategyTests`)

  * Успех при ограниченном запасе (проверка состава).
  * Неуспех при невозможной сумме из доступных номиналов.
  * Тривиальный ноль — всегда возможен.

* **Касса** (`CashRegisterTests`)

  * «Внёс и вернул» — возврат **ровно** того, что внесли; hopper обнуляется.
  * Пополнение `vault`/полное снятие — балансы сходятся.
  * Возможность сдачи считается на объединённом снимке `(vault+hopper)`.

* **Покупатель** (`VendingMachineTests`)

  * Успешная покупка: корректная сдача, списание склада.
  * Отказы: недостаточно средств, невозможна сдача, нет/кончился товар.
  * Отмена — возвращает монеты и обнуляет внесённую сумму.

* **Админ** (`AdminSessionTests`)

  * Неверный PIN — отказ; верный — получение сессии.
  * Пополнение товара/кассы, снятие всей наличности, снапшоты `vault/hopper`.

### Почему тесты «самодокументирующиеся»

* **Говорящие названия**: `Buy_Succeeds_AndGivesCorrectChange`, `Greedy_TryMakeChange_Fails_WhenOddSumButOnlyEvenCoins` — читаются как спецификация.
* **AAA-структура** (Arrange-Act-Assert) — одно действие, проверяем несмещённо.
* **Без неустойчивых зависимостей**: нет случайности/времени/IO; культура явно `ru-RU`.
* **Покрытие ветвей**: успех/отказ/границы отражают доменную логику и её инварианты.

---

## Детали реализации, на которые стоит обратить внимание

* `sealed` классы (`Drink`, `Snack`, стратегия) — **контролируемое наследование** без лишней иерархии.
* `Snapshot()`/`EmptyVault()`/**копии словарей** — защита от внешней мутации.
* `Try*`-методы там, где отказ — нормальная ветка исполнения; исключения — для невозможных состояний.
* `ToString()` в `CurrencyAmount` — локализация и стабильный формат для UI/логов.
* `Result<Receipt>` — возвращает полный контекст операции (товар, цена, внесено, сдача и её разложение по номиналам).

---

## Запуск

```bash
# сборка
dotnet build

# запуск приложения
dotnet run --project ./vending_machine

# запуск тестов
dotnet test
```
